package post

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	pogo "github.com/livebud/weblog/bud/pkg/table"
	"github.com/livebud/weblog/bud/pkg/table/enum"
	"github.com/matthewmueller/bud/di"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrPostNotFound returned if the "public"."posts" is not found
var ErrPostNotFound = errors.New("post not found")

// Post result data for "public"."posts"
type Post struct {
	AuthorID  int             `json:"author_id,omitempty"`
	Body      string          `json:"body,omitempty"`
	CreatedAt time.Time       `json:"created_at,omitempty"`
	ID        int             `json:"id,omitempty"`
	Slug      string          `json:"slug,omitempty"`
	Status    enum.PostStatus `json:"status,omitempty"`
	Title     string          `json:"title,omitempty"`
	UpdatedAt time.Time       `json:"updated_at,omitempty"`
}

var _ pogo.Row = (*Post)(nil)

// Decode implements pogo.Row
func (p *Post) Decode(post interface{}) error {
	_post, ok := post.(*Post)
	if !ok {
		return fmt.Errorf(`post decode: "%T" is not a "*Post"`, post)
	}
	*_post = *p
	return nil
}

// New "public"."posts" input
func New() *Input {
	return &Input{}
}

// Input data for "public"."posts"
type Input struct {
	authorID  *int
	body      *string
	createdAt *time.Time
	id        *int
	slug      *string
	status    *enum.PostStatus
	title     *string
	updatedAt *time.Time
}

var _ pogo.Insertable = (*Input)(nil)

// AuthorID sets the author_id
func (p *Input) AuthorID(authorID int) *Input {
	p.authorID = &authorID
	return p
}

// Body sets the body
func (p *Input) Body(body string) *Input {
	p.body = &body
	return p
}

// CreatedAt sets the created_at
func (p *Input) CreatedAt(createdAt time.Time) *Input {
	p.createdAt = &createdAt
	return p
}

// ID sets the id
func (p *Input) ID(id int) *Input {
	p.id = &id
	return p
}

// Slug sets the slug
func (p *Input) Slug(slug string) *Input {
	p.slug = &slug
	return p
}

// Status sets the status
func (p *Input) Status(status enum.PostStatus) *Input {
	p.status = &status
	return p
}

// Title sets the title
func (p *Input) Title(title string) *Input {
	p.title = &title
	return p
}

// UpdatedAt sets the updated_at
func (p *Input) UpdatedAt(updatedAt time.Time) *Input {
	p.updatedAt = &updatedAt
	return p
}

// MarshalJSON marshals the "post" into JSON
func (p *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(p)
}

// UnmarshalJSON unmarshals json to a "post"
func (p *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, p)
}

// String of the input
// TODO: make this more useful
func (p *Input) String() string {
	return `"public"."posts"`
}

func (p *Input) columns() map[string]interface{} {
	columns := make(map[string]interface{})

	if p.authorID != nil {
		columns["author_id"] = *p.authorID
	}

	if p.body != nil {
		columns["body"] = *p.body
	}

	if p.createdAt != nil {
		columns["created_at"] = *p.createdAt
	}

	if p.id != nil {
		columns["id"] = *p.id
	}

	if p.slug != nil {
		columns["slug"] = *p.slug
	}

	if p.status != nil {
		columns["status"] = *p.status
	}

	if p.title != nil {
		columns["title"] = *p.title
	}

	if p.updatedAt != nil {
		columns["updated_at"] = *p.updatedAt
	}

	return columns
}

// Insert implements pogo.Insertable
func (p *Input) Insert(db pogo.DB) (pogo.Row, error) {
	return Insert(db, p)
}

// NewFilter creates a new filter
func NewFilter() *Filter {
	return &Filter{}
}

// Filter filters for "public"."posts"
type Filter struct {
	formats []string
	values  []interface{}
	error   error
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
		Error:  f.error,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

// AuthorID author_id equals
func (f *Filter) AuthorID(v int) *Filter {
	f.formats = append(f.formats, `"author_id" = %s`)
	f.values = append(f.values, v)
	return f
}

// AuthorIDNot author_id doesn't equal
func (f *Filter) AuthorIDNot(v int) *Filter {
	f.formats = append(f.formats, `"author_id" != %s`)
	f.values = append(f.values, v)
	return f
}

// AuthorIDLt author_id is less than
func (f *Filter) AuthorIDLt(v int) *Filter {
	f.formats = append(f.formats, `"author_id" < %s`)
	f.values = append(f.values, v)
	return f
}

// AuthorIDLte author_id is less than or equal
func (f *Filter) AuthorIDLte(v int) *Filter {
	f.formats = append(f.formats, `"author_id" <= %s`)
	f.values = append(f.values, v)
	return f
}

// AuthorIDGt author_id is greater than
func (f *Filter) AuthorIDGt(v int) *Filter {
	f.formats = append(f.formats, `"author_id" > %s`)
	f.values = append(f.values, v)
	return f
}

// AuthorIDGte author_id is greater than or equal
func (f *Filter) AuthorIDGte(v int) *Filter {
	f.formats = append(f.formats, `"author_id" >= %s`)
	f.values = append(f.values, v)
	return f
}

// AuthorIDIn author_id is in
func (f *Filter) AuthorIDIn(v ...int) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"author_id" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// AuthorIDNotIn author_id is not in
func (f *Filter) AuthorIDNotIn(v ...int) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"author_id" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// Body body equals
func (f *Filter) Body(v string) *Filter {
	f.formats = append(f.formats, `"body" = %s`)
	f.values = append(f.values, v)
	return f
}

// BodyNot body doesn't equal
func (f *Filter) BodyNot(v string) *Filter {
	f.formats = append(f.formats, `"body" != %s`)
	f.values = append(f.values, v)
	return f
}

// BodyContains body contains
func (f *Filter) BodyContains(v string) *Filter {
	f.formats = append(f.formats, `"body" LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// BodyNotContains body doesn't contain
func (f *Filter) BodyNotContains(v string) *Filter {
	f.formats = append(f.formats, `"body" NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// BodyStartsWith body starts with
func (f *Filter) BodyStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"body" LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// BodyNotStartsWith body doesn't start with
func (f *Filter) BodyNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"body" NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// BodyEndsWith body ends with
func (f *Filter) BodyEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"body" LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// BodyNotEndsWith body doesn't end with
func (f *Filter) BodyNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"body" NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// BodyLt body is less than
func (f *Filter) BodyLt(v string) *Filter {
	f.formats = append(f.formats, `"body" < %s`)
	f.values = append(f.values, v)
	return f
}

// BodyLte body is less than or equal
func (f *Filter) BodyLte(v string) *Filter {
	f.formats = append(f.formats, `"body" <= %s`)
	f.values = append(f.values, v)
	return f
}

// BodyGt body is greater than
func (f *Filter) BodyGt(v string) *Filter {
	f.formats = append(f.formats, `"body" > %s`)
	f.values = append(f.values, v)
	return f
}

// BodyGte body is greater than or equal
func (f *Filter) BodyGte(v string) *Filter {
	f.formats = append(f.formats, `"body" >= %s`)
	f.values = append(f.values, v)
	return f
}

// BodyIn body is in
func (f *Filter) BodyIn(v ...string) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"body" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// BodyNotIn body is not in
func (f *Filter) BodyNotIn(v ...string) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"body" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// CreatedAt created_at is equal to
func (f *Filter) CreatedAt(v time.Time) *Filter {
	f.formats = append(f.formats, `"created_at" = %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// CreatedAtNot created_at is not equal to
func (f *Filter) CreatedAtNot(v time.Time) *Filter {
	f.formats = append(f.formats, `"created_at" != %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// CreatedAtIn created_at is in
func (f *Filter) CreatedAtIn(v ...time.Time) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"created_at" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i.Format("2006-01-02 15:04:05.999999999Z07:00"))
	}
	return f
}

// CreatedAtNotIn created_at is not in
func (f *Filter) CreatedAtNotIn(v ...time.Time) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"created_at" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i.Format("2006-01-02 15:04:05.999999999Z07:00"))
	}
	return f
}

// CreatedAtLt created_at is less than
func (f *Filter) CreatedAtLt(v time.Time) *Filter {
	f.formats = append(f.formats, `"created_at" < %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// CreatedAtLte created_at is less than or equal
func (f *Filter) CreatedAtLte(v time.Time) *Filter {
	f.formats = append(f.formats, `"created_at" <= %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// CreatedAtGt created_at is greater than
func (f *Filter) CreatedAtGt(v time.Time) *Filter {
	f.formats = append(f.formats, `"created_at" > %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// CreatedAtGte created_at is greater than or equal
func (f *Filter) CreatedAtGte(v time.Time) *Filter {
	f.formats = append(f.formats, `"created_at" >= %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// ID id equals
func (f *Filter) ID(v int) *Filter {
	f.formats = append(f.formats, `"id" = %s`)
	f.values = append(f.values, v)
	return f
}

// IDNot id doesn't equal
func (f *Filter) IDNot(v int) *Filter {
	f.formats = append(f.formats, `"id" != %s`)
	f.values = append(f.values, v)
	return f
}

// IDLt id is less than
func (f *Filter) IDLt(v int) *Filter {
	f.formats = append(f.formats, `"id" < %s`)
	f.values = append(f.values, v)
	return f
}

// IDLte id is less than or equal
func (f *Filter) IDLte(v int) *Filter {
	f.formats = append(f.formats, `"id" <= %s`)
	f.values = append(f.values, v)
	return f
}

// IDGt id is greater than
func (f *Filter) IDGt(v int) *Filter {
	f.formats = append(f.formats, `"id" > %s`)
	f.values = append(f.values, v)
	return f
}

// IDGte id is greater than or equal
func (f *Filter) IDGte(v int) *Filter {
	f.formats = append(f.formats, `"id" >= %s`)
	f.values = append(f.values, v)
	return f
}

// IDIn id is in
func (f *Filter) IDIn(v ...int) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"id" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// IDNotIn id is not in
func (f *Filter) IDNotIn(v ...int) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"id" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// Slug slug equals
func (f *Filter) Slug(v string) *Filter {
	f.formats = append(f.formats, `"slug" = %s`)
	f.values = append(f.values, v)
	return f
}

// SlugNot slug doesn't equal
func (f *Filter) SlugNot(v string) *Filter {
	f.formats = append(f.formats, `"slug" != %s`)
	f.values = append(f.values, v)
	return f
}

// SlugContains slug contains
func (f *Filter) SlugContains(v string) *Filter {
	f.formats = append(f.formats, `"slug" LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlugNotContains slug doesn't contain
func (f *Filter) SlugNotContains(v string) *Filter {
	f.formats = append(f.formats, `"slug" NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlugStartsWith slug starts with
func (f *Filter) SlugStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"slug" LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlugNotStartsWith slug doesn't start with
func (f *Filter) SlugNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"slug" NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlugEndsWith slug ends with
func (f *Filter) SlugEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"slug" LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// SlugNotEndsWith slug doesn't end with
func (f *Filter) SlugNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"slug" NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// SlugLt slug is less than
func (f *Filter) SlugLt(v string) *Filter {
	f.formats = append(f.formats, `"slug" < %s`)
	f.values = append(f.values, v)
	return f
}

// SlugLte slug is less than or equal
func (f *Filter) SlugLte(v string) *Filter {
	f.formats = append(f.formats, `"slug" <= %s`)
	f.values = append(f.values, v)
	return f
}

// SlugGt slug is greater than
func (f *Filter) SlugGt(v string) *Filter {
	f.formats = append(f.formats, `"slug" > %s`)
	f.values = append(f.values, v)
	return f
}

// SlugGte slug is greater than or equal
func (f *Filter) SlugGte(v string) *Filter {
	f.formats = append(f.formats, `"slug" >= %s`)
	f.values = append(f.values, v)
	return f
}

// SlugIn slug is in
func (f *Filter) SlugIn(v ...string) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"slug" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// SlugNotIn slug is not in
func (f *Filter) SlugNotIn(v ...string) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"slug" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// Status status is equal to
func (f *Filter) Status(v enum.PostStatus) *Filter {
	f.formats = append(f.formats, `"status" = %s`)
	f.values = append(f.values, v)
	return f
}

// StatusNot status is not equal to
func (f *Filter) StatusNot(v enum.PostStatus) *Filter {
	f.formats = append(f.formats, `"status" != %s`)
	f.values = append(f.values, v)
	return f
}

// StatusIn status is in
func (f *Filter) StatusIn(v ...enum.PostStatus) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"status" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// StatusNotIn status is not in
func (f *Filter) StatusNotIn(v ...enum.PostStatus) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"status" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// Title title equals
func (f *Filter) Title(v string) *Filter {
	f.formats = append(f.formats, `"title" = %s`)
	f.values = append(f.values, v)
	return f
}

// TitleNot title doesn't equal
func (f *Filter) TitleNot(v string) *Filter {
	f.formats = append(f.formats, `"title" != %s`)
	f.values = append(f.values, v)
	return f
}

// TitleContains title contains
func (f *Filter) TitleContains(v string) *Filter {
	f.formats = append(f.formats, `"title" LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TitleNotContains title doesn't contain
func (f *Filter) TitleNotContains(v string) *Filter {
	f.formats = append(f.formats, `"title" NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TitleStartsWith title starts with
func (f *Filter) TitleStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"title" LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TitleNotStartsWith title doesn't start with
func (f *Filter) TitleNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"title" NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TitleEndsWith title ends with
func (f *Filter) TitleEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"title" LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// TitleNotEndsWith title doesn't end with
func (f *Filter) TitleNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"title" NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// TitleLt title is less than
func (f *Filter) TitleLt(v string) *Filter {
	f.formats = append(f.formats, `"title" < %s`)
	f.values = append(f.values, v)
	return f
}

// TitleLte title is less than or equal
func (f *Filter) TitleLte(v string) *Filter {
	f.formats = append(f.formats, `"title" <= %s`)
	f.values = append(f.values, v)
	return f
}

// TitleGt title is greater than
func (f *Filter) TitleGt(v string) *Filter {
	f.formats = append(f.formats, `"title" > %s`)
	f.values = append(f.values, v)
	return f
}

// TitleGte title is greater than or equal
func (f *Filter) TitleGte(v string) *Filter {
	f.formats = append(f.formats, `"title" >= %s`)
	f.values = append(f.values, v)
	return f
}

// TitleIn title is in
func (f *Filter) TitleIn(v ...string) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"title" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// TitleNotIn title is not in
func (f *Filter) TitleNotIn(v ...string) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"title" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// UpdatedAt updated_at is equal to
func (f *Filter) UpdatedAt(v time.Time) *Filter {
	f.formats = append(f.formats, `"updated_at" = %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// UpdatedAtNot updated_at is not equal to
func (f *Filter) UpdatedAtNot(v time.Time) *Filter {
	f.formats = append(f.formats, `"updated_at" != %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// UpdatedAtIn updated_at is in
func (f *Filter) UpdatedAtIn(v ...time.Time) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"updated_at" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i.Format("2006-01-02 15:04:05.999999999Z07:00"))
	}
	return f
}

// UpdatedAtNotIn updated_at is not in
func (f *Filter) UpdatedAtNotIn(v ...time.Time) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"updated_at" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i.Format("2006-01-02 15:04:05.999999999Z07:00"))
	}
	return f
}

// UpdatedAtLt updated_at is less than
func (f *Filter) UpdatedAtLt(v time.Time) *Filter {
	f.formats = append(f.formats, `"updated_at" < %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// UpdatedAtLte updated_at is less than or equal
func (f *Filter) UpdatedAtLte(v time.Time) *Filter {
	f.formats = append(f.formats, `"updated_at" <= %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// UpdatedAtGt updated_at is greater than
func (f *Filter) UpdatedAtGt(v time.Time) *Filter {
	f.formats = append(f.formats, `"updated_at" > %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// UpdatedAtGte updated_at is greater than or equal
func (f *Filter) UpdatedAtGte(v time.Time) *Filter {
	f.formats = append(f.formats, `"updated_at" >= %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// OrderBy specificies the ORDERBy BY <order>
type OrderBy string

const (
	// ASC sorts by ascending order
	ASC OrderBy = "ASC"

	// DESC sorts by descending order
	DESC OrderBy = "DESC"
)

// NewOrder fn
func NewOrder() *Orderer {
	return &Orderer{}
}

var _ pogo.Condition = (*Orderer)(nil)

// Orderer orders the given fields
type Orderer struct {
	formats []string
}

// Clause fn
func (o *Orderer) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

// AuthorID sorts "author_id" by an expression
func (o *Orderer) AuthorID(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"author_id" %s`, order))
	return o
}

// Body sorts "body" by an expression
func (o *Orderer) Body(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"body" %s`, order))
	return o
}

// CreatedAt sorts "created_at" by an expression
func (o *Orderer) CreatedAt(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"created_at" %s`, order))
	return o
}

// ID sorts "id" by an expression
func (o *Orderer) ID(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"id" %s`, order))
	return o
}

// Slug sorts "slug" by an expression
func (o *Orderer) Slug(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"slug" %s`, order))
	return o
}

// Status sorts "status" by an expression
func (o *Orderer) Status(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"status" %s`, order))
	return o
}

// Title sorts "title" by an expression
func (o *Orderer) Title(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"title" %s`, order))
	return o
}

// UpdatedAt sorts "updated_at" by an expression
func (o *Orderer) UpdatedAt(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"updated_at" %s`, order))
	return o
}

func Provider(in di.Injector) {
	di.Provide[*Model](in, provideModel)
}

func provideModel(in di.Injector) (*Model, error) {
	return &Model{}, nil
}

// Model is an empty struct that has all the methods.
// It's primarly used for embedding the methods
// into higher-level models.
type Model struct{}

// Insert a ""public"."posts"" into the "public"."posts"
func Insert(db pogo.DB, post *Input) (*Post, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(post.columns(), 0)
	_ = _i

	// sql insert query, primary key provided by sequence
	var sqlstr string
	if len(_c) == 0 {
		sqlstr = `
      INSERT INTO "public"."posts"
      DEFAULT VALUES
      RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"
    `
	} else {
		sqlstr = `
      INSERT INTO "public"."posts" (` + strings.Join(_c, ", ") + `)
      VALUES (` + strings.Join(_i, ", ") + `)
      RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"
    `
	}

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		return nil, e
	}

	return &_post, nil
}

// Insert a ""public"."posts"" into the "public"."posts"
func (*Model) Insert(db pogo.DB, post *Input) (*Post, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(post.columns(), 0)
	_ = _i

	// sql insert query, primary key provided by sequence
	var sqlstr string
	if len(_c) == 0 {
		sqlstr = `
      INSERT INTO "public"."posts"
      DEFAULT VALUES
      RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"
    `
	} else {
		sqlstr = `
      INSERT INTO "public"."posts" (` + strings.Join(_c, ", ") + `)
      VALUES (` + strings.Join(_i, ", ") + `)
      RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"
    `
	}

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		return nil, e
	}

	return &_post, nil
}

// InsertMany ""public"."posts"" into the "public"."posts"
func InsertMany(db pogo.DB, posts ...*Input) ([]*Post, error) {
	_posts := []*Post{}
	for _, post := range posts {
		_post, err := Insert(db, post)
		if err != nil {
			return _posts, err
		}
		_posts = append(_posts, _post)
	}
	return _posts, nil
}

// InsertMany ""public"."posts"" into the "public"."posts"
func (*Model) InsertMany(db pogo.DB, posts ...*Input) ([]*Post, error) {
	_posts := []*Post{}
	for _, post := range posts {
		_post, err := Insert(db, post)
		if err != nil {
			return _posts, err
		}
		_posts = append(_posts, _post)
	}
	return _posts, nil
}

// Find a `Post` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*Post, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at" ` +
		`FROM "public"."posts" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// Find a `Post` by some conditions.
func (*Model) Find(db pogo.DB, conds ...pogo.Condition) (*Post, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at" ` +
		`FROM "public"."posts" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// FindByID a `Post` by some conditions.
func FindByID(db pogo.DB, id int) (*Post, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"
    FROM "public"."posts"
    WHERE "id" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, id)
	}

	var _post Post
	row := db.QueryRow(sqlstr, id)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// FindByID a `Post` by some conditions.
func (*Model) FindByID(db pogo.DB, id int) (*Post, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"
    FROM "public"."posts"
    WHERE "id" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, id)
	}

	var _post Post
	row := db.QueryRow(sqlstr, id)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// FindBySlug find a post by slug
func FindBySlug(db pogo.DB, slug string) (*Post, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"
    FROM "public"."posts"
    WHERE "slug" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, slug)
	}

	var _post Post
	row := db.QueryRow(sqlstr, slug)
	err := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt)
	if err != nil {
		if pogo.IsNoRows(err) {
			return nil, ErrPostNotFound
		}
		return nil, err
	}

	return &_post, nil
}

// FindBySlug find a post by slug
func (*Model) FindBySlug(db pogo.DB, slug string) (*Post, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"
    FROM "public"."posts"
    WHERE "slug" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, slug)
	}

	var _post Post
	row := db.QueryRow(sqlstr, slug)
	err := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt)
	if err != nil {
		if pogo.IsNoRows(err) {
			return nil, ErrPostNotFound
		}
		return nil, err
	}
	return &_post, nil
}

// FindMany finds many "public"."posts" by a condition
func FindMany(db pogo.DB, conds ...pogo.Condition) ([]*Post, error) {
	posts := []*Post{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return posts, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at" ` +
		`FROM "public"."posts" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return posts, err
	}
	defer rows.Close()

	for rows.Next() {
		var _post Post
		if e := rows.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
			if pogo.IsNoRows(e) {
				return posts, ErrPostNotFound
			}
			return posts, err
		}
		posts = append(posts, &_post)
	}
	if rows.Err() != nil {
		return posts, rows.Err()
	}

	return posts, nil
}

// FindMany finds many "public"."posts" by a condition
func (*Model) FindMany(db pogo.DB, conds ...pogo.Condition) ([]*Post, error) {
	posts := []*Post{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return posts, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at" ` +
		`FROM "public"."posts" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return posts, err
	}
	defer rows.Close()

	for rows.Next() {
		var _post Post
		if e := rows.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
			if pogo.IsNoRows(e) {
				return posts, ErrPostNotFound
			}
			return posts, err
		}
		posts = append(posts, &_post)
	}
	if rows.Err() != nil {
		return posts, rows.Err()
	}

	return posts, nil
}

// Update ""public"."posts"" rows in "public"."posts" by a condition, returning 1 result
func Update(db pogo.DB, post *Input, conds ...pogo.Condition) (*Post, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := post.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("post.Update: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."posts" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// Update ""public"."posts"" rows in "public"."posts" by a condition, returning 1 result
func (*Model) Update(db pogo.DB, post *Input, conds ...pogo.Condition) (*Post, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := post.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("post.Update: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."posts" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// UpdateMany updates ""public"."posts"" rows in "public"."posts" by conditions, returning all results
func UpdateMany(db pogo.DB, post *Input, conds ...pogo.Condition) ([]*Post, error) {
	posts := []*Post{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := post.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("post.UpdateMany: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."posts" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return posts, err
	}
	defer rows.Close()

	for rows.Next() {
		var _post Post
		if e := rows.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
			if pogo.IsNoRows(e) {
				return posts, ErrPostNotFound
			}
			return posts, err
		}
		posts = append(posts, &_post)
	}
	if rows.Err() != nil {
		return posts, rows.Err()
	}

	return posts, nil
}

// UpdateMany updates ""public"."posts"" rows in "public"."posts" by conditions, returning all results
func (*Model) UpdateMany(db pogo.DB, post *Input, conds ...pogo.Condition) ([]*Post, error) {
	posts := []*Post{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := post.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("post.UpdateMany: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."posts" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return posts, err
	}
	defer rows.Close()

	for rows.Next() {
		var _post Post
		if e := rows.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
			if pogo.IsNoRows(e) {
				return posts, ErrPostNotFound
			}
			return posts, err
		}
		posts = append(posts, &_post)
	}
	if rows.Err() != nil {
		return posts, rows.Err()
	}

	return posts, nil
}

// UpdateByID a "post" in "public"."posts" by its ""id""
func UpdateByID(db pogo.DB, id int, post *Input) (*Post, error) {
	// add values to input, overriding existing keys if present in the input
	post = post.ID(id)

	// get the columns
	fields := post.columns()

	// don't update the keys
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("post.UpdateByID: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."posts" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "id" = $1 ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, id)
	values = append(values, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// UpdateByID a "post" in "public"."posts" by its ""id""
func (*Model) UpdateByID(db pogo.DB, id int, post *Input) (*Post, error) {
	// add values to input, overriding existing keys if present in the input
	post = post.ID(id)

	// get the columns
	fields := post.columns()

	// don't update the keys
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("post.UpdateByID: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."posts" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "id" = $1 ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, id)
	values = append(values, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// UpdateBySlug find a Post
func UpdateBySlug(db pogo.DB, slug string, post *Input) (*Post, error) {
	// add values to input, overriding existing keys if present in the input
	post = post.Slug(slug)

	// get the columns
	fields := post.columns()

	// don't update the keys
	delete(fields, "slug")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("post.UpdateBySlug: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."posts" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "slug" = $1 ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, slug)
	values = append(values, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// UpdateBySlug find a Post
func (*Model) UpdateBySlug(db pogo.DB, slug string, post *Input) (*Post, error) {
	// add values to input, overriding existing keys if present in the input
	post = post.Slug(slug)

	// get the columns
	fields := post.columns()

	// don't update the keys
	delete(fields, "slug")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("post.UpdateBySlug: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."posts" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "slug" = $1 ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, slug)
	values = append(values, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// Delete `Post`s by some conditions. Returns the first result.
// Warning: This can delete more than 1 row
func Delete(db pogo.DB, conds ...pogo.Condition) (*Post, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "public"."posts" ` +
		_s + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// Delete `Post`s by some conditions. Returns the first result.
// Warning: This can delete more than 1 row
func (*Model) Delete(db pogo.DB, conds ...pogo.Condition) (*Post, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "public"."posts" ` +
		_s + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// DeleteMany `Post`s by some conditions, returning all results.
func DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*Post, error) {
	posts := []*Post{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return posts, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "public"."posts" ` +
		_s + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return posts, err
	}
	defer rows.Close()

	for rows.Next() {
		var _post Post
		if e := rows.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
			if pogo.IsNoRows(e) {
				return posts, ErrPostNotFound
			}
			return posts, err
		}
		posts = append(posts, &_post)
	}
	if rows.Err() != nil {
		return posts, rows.Err()
	}

	return posts, nil
}

// DeleteMany `Post`s by some conditions, returning all results.
func (*Model) DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*Post, error) {
	posts := []*Post{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return posts, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "public"."posts" ` +
		_s + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return posts, err
	}
	defer rows.Close()

	for rows.Next() {
		var _post Post
		if e := rows.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
			if pogo.IsNoRows(e) {
				return posts, ErrPostNotFound
			}
			return posts, err
		}
		posts = append(posts, &_post)
	}
	if rows.Err() != nil {
		return posts, rows.Err()
	}

	return posts, nil
}

// DeleteByID deletes a "post"
func DeleteByID(db pogo.DB, id int) (*Post, error) {
	// sql delete query
	sqlstr := `DELETE FROM "public"."posts" ` +
		`WHERE "id" = $1 ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, id)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, id)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// DeleteByID deletes a "post"
func (*Model) DeleteByID(db pogo.DB, id int) (*Post, error) {
	// sql delete query
	sqlstr := `DELETE FROM "public"."posts" ` +
		`WHERE "id" = $1 ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, id)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, id)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// DeleteBySlug deletes a "post"
func DeleteBySlug(db pogo.DB, slug string) (*Post, error) {
	// sql delete query
	sqlstr := `DELETE FROM "public"."posts" ` +
		`WHERE "slug" = $1 ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, slug)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, slug)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// DeleteBySlug deletes a "post"
func (*Model) DeleteBySlug(db pogo.DB, slug string) (*Post, error) {
	// sql delete query
	sqlstr := `DELETE FROM "public"."posts" ` +
		`WHERE "slug" = $1 ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, slug)
	}

	// run the query
	var _post Post
	row := db.QueryRow(sqlstr, slug)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrPostNotFound
		}
		return nil, e
	}

	return &_post, nil
}

// Upsert inserts a `"public"."posts"`, updating the row if `"id"` already exists.
func Upsert(db pogo.DB, post *Input) (*Post, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(post.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."posts" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_post, nil
}

// Upsert inserts a `"public"."posts"`, updating the row if `"id"` already exists.
func (*Model) Upsert(db pogo.DB, post *Input) (*Post, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(post.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."posts" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_post, nil
}

// UpsertByID inserts a `"public"."posts"`, updating the row if `"id"` already exists.
func UpsertByID(db pogo.DB, id int, post *Input) (*Post, error) {
	// add values to input, overriding existing keys if present in the input
	post = post.ID(id)

	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(post.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."posts" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_post, nil
}

// UpsertByID inserts a `"public"."posts"`, updating the row if `"id"` already exists.
func (*Model) UpsertByID(db pogo.DB, id int, post *Input) (*Post, error) {
	// add values to input, overriding existing keys if present in the input
	post = post.ID(id)

	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(post.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."posts" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_post, nil
}

// UpsertBySlug inserts a `"public"."posts"`, updating the row if `"slug"` already exists.
func UpsertBySlug(db pogo.DB, slug string, post *Input) (*Post, error) {
	// add values to input, overriding existing keys if present in the input
	post = post.Slug(slug)

	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(post.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."posts" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slug") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_post, nil
}

// UpsertBySlug inserts a `"public"."posts"`, updating the row if `"slug"` already exists.
func (*Model) UpsertBySlug(db pogo.DB, slug string, post *Input) (*Post, error) {
	// add values to input, overriding existing keys if present in the input
	post = post.Slug(slug)

	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(post.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."posts" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slug") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "author_id", "body", "created_at", "id", "slug", "status", "title", "updated_at"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _post Post
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_post.AuthorID, &_post.Body, &_post.CreatedAt, &_post.ID, &_post.Slug, &_post.Status, &_post.Title, &_post.UpdatedAt); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_post, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, strconv.Quote(col))
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}
